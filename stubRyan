/******************************************************************************|
| CPSC 4050/6050 Computer Garphics Assignment 5, Daljit Singh Dhillon, 2020    |
| Reference:                                                                   |
|                                                                              |
| Some OpenGL setup code here including math_funcs, and gl_utils               |
| are from Angton Gerdelan and "Anton's OpenGL 4 Tutorials."                   |
| http://antongerdelan.net/opengl/                                             |
| Email: anton at antongerdelan dot net                                        |
| Copyright Dr Anton Gerdelan, Trinity College Dublin, Ireland.                |
|******************************************************************************/
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <assert.h>
#include <iostream>
#include <vector>


#include <math.h>
#include <time.h>

#include "maths_funcs.h"   // Anton's maths functions.
#include "gl_utils.h"      // Anton's opengl functions and small utilities like logs
#include "stb_image.h"     // Sean Barrett's image loader with Anton's load_texture()

#define _USE_MATH_DEFINES
#define ONE_DEG_IN_RAD (2.0 * M_PI) / 360.0 // 0.017444444


mat4 view_mat;
mat4 proj_mat;
mat4 model_mat;


int pointCount;
int basePointCount;

void loadSurfaceOfRevolution() 
{
/*------------------------------CREATE GEOMETRY-------------------------------*/
	int stepsY = 0;
	int stepsT = 0;

	std::cout<<"Enter how many steps along the Y axis: ";
	std::cin>>stepsY;
	while(stepsY < 3){
		std::cout<<"Must be at least 3 steps. Please Re-enter: ";
		std::cin>>stepsY;
	}
	std::cout<<"Enter how many steps around the y axis: ";
	std::cin>>stepsT;
	while(stepsT < 3){
		std::cout<<"Must be at least 3 steps. Please Re-enter: ";
		std::cin>>stepsT;
	}

	//calcluate points along the base curve (circular arc with equation x^2 + y^2 = 1)
	std::vector<float> basePoints;
	for(int i=0; i<=stepsY; i++){
		float y = 1.0 - (i*(2.0/stepsY));
		float x = sqrt(1.0-pow(y, 2));
		//float x = -1*pow(y, 2) + 1;
		//float x = sqrt(y+1);

		basePoints.push_back(x);
		basePoints.push_back(y);
		basePoints.push_back(2);

		//std::cout<< x << ", " << y << "\n";
	}
	basePointCount = basePoints.size();


	//calculate all verticies based on the base curve at each step of theta
	pointCount = stepsY*stepsT;
	
	GLfloat vp[pointCount*18];    //array of vertex points
	GLfloat normals[pointCount*18]; //array of normals
	GLfloat vt[pointCount*12]; //array of texture coordinates

	//for each level of Y, starting from the top, iterate through each vertex
	for(int i = 0; i < stepsY; i++){
		for(int j = 0; j < stepsT; j++){
			int vIndex = (i*stepsY*18)+(j*18);
			int nIndex = (i*stepsY*18)+(j*18);
			int tIndex = (i*stepsY*12)+(j*12);

			GLfloat Pij[3] = {basePoints[i*3]*cos(j*(2*M_PI/stepsT)),
							  basePoints[i*3+1],
							  basePoints[i*3]*sin(j*(2*M_PI/stepsT))};
			GLfloat Piij[3] = {basePoints[(i+1)*3]*cos(j*(2*M_PI/stepsT)),
							   basePoints[(i+1)*3+1],
							   basePoints[(i+1)*3]*sin(j*(2*M_PI/stepsT))};
			GLfloat Pijj[3] = {basePoints[i*3]*cos((j+1)*(2*M_PI/stepsT)),
							   basePoints[i*3+1],
							   basePoints[i*3]*sin((j+1)*(2*M_PI/stepsT))};
			GLfloat Piijj[3] = {basePoints[(i+1)*3]*cos((j+1)*(2*M_PI/stepsT)),
							    basePoints[(i+1)*3+1],
								basePoints[(i+1)*3]*sin((j+1)*(2*M_PI/stepsT))};

			//load the points of the two triangles with their top left corner at P i,j
			//P i,j
			vp[vIndex+0] = Pij[0]; //x
			vp[vIndex+1] = Pij[1]; //y
			vp[vIndex+2] = Pij[2]; //z
			
			//P i+1,j+1
			vp[vIndex+3] = Piijj[0]; //x
			vp[vIndex+4] = Piijj[1]; //y
			vp[vIndex+5] = Piijj[2]; //z
			
			//P i,j+1
			vp[vIndex+6] = Pijj[0]; //x
			vp[vIndex+7] = Pijj[1]; //y
			vp[vIndex+8] = Pijj[2]; //z
			
			//P i,j
			vp[vIndex+9] = Pij[0]; //x
			vp[vIndex+10] = Pij[1]; //y
			vp[vIndex+11] = Pij[2]; //z
			
			//P i+1,j
			vp[vIndex+12] = Piij[0]; //x
			vp[vIndex+13] = Piij[1]; //y
			vp[vIndex+14] = Piij[2]; //z
			
			//P i+1,j+1
			vp[vIndex+15] = Piijj[0]; //x
			vp[vIndex+16] = Piijj[1]; //y
			vp[vIndex+17] = Piijj[2]; //z
			
			/*
			//calculate and load the normals for the two triangles with their top left corner at P i,j
			
			//////////////////2/////////////////////
			//calculate surface edges adjacent to the vertex
			GLfloat edge1A[3] = {Piijj[0] - Pij[0],
								 Piijj[1] - Pij[1],
								 Piijj[2] - Pij[2]};
			GLfloat edge1B[3] = {Pijj[0] - Pij[0],
								 Pijj[1] - Pij[1],
								 Pijj[2] - Pij[2]};
			
			//calculate cross product of the edges
			GLfloat cross1[3] = {edge1A[1]*edge1B[2] - edge1A[2]*edge1B[1],
								 edge1A[2]*edge1B[0] - edge1A[0]*edge1B[2],
								 edge1A[0]*edge1B[1] - edge1A[1]*edge1B[0]};
			//normalize the cross product to calculate the normal for this vertex
			GLfloat length1 = sqrt(pow(cross1[0], 2) + pow(cross1[1], 2) + pow(cross1[2], 2));
			GLfloat normal1[3] = {cross1[0]/length1,
								  cross1[1]/length1,
								  cross1[2]/length1};
			
			//////////////////////2///////////////////
			//calculate surface edges adjacent to the vertex
			GLfloat edge2A[3] = {Pijj[0] - Piijj[0],
								 Pijj[1] - Piijj[1],
								 Pijj[2] - Piijj[2]};
			GLfloat edge2B[3] = {Pij[0] - Piijj[0],
								 Pij[1] - Piijj[1],
								 Pij[2] - Piijj[2]};

			//calculate cross product of the edges
			GLfloat cross2[3] = {edge2A[1]*edge2B[2] - edge2A[2]*edge2B[1],
								 edge2A[2]*edge2B[0] - edge2A[0]*edge2B[2],
								 edge2A[0]*edge2B[1] - edge2A[1]*edge2B[0]};
			//normalize the cross product to calculate the normal for this vertex
			GLfloat length2 = sqrt(pow(cross1[0], 2) + pow(cross1[1], 2) + pow(cross1[2], 2));
			GLfloat normal2[3] = {cross2[0]/length2,
								  cross2[1]/length2,
								  cross2[2]/length2};

			////////////////////////3/////////////////////
			//calculate surface edges adjacent to the vertex
			GLfloat edge3A[3] = {Pij[0] - Pijj[0],
								 Pij[1] - Pijj[1],
								 Pij[2] - Pijj[2]};
			GLfloat edge3B[3] = {Piijj[0] - Pijj[0],
								 Piijj[1] - Pijj[1],
								 Piijj[2] - Pijj[2]};
			
			//calculate cross product of the edges
			GLfloat cross3[3] = {edge3A[1]*edge3B[2] - edge3A[2]*edge3B[1],
								 edge3A[2]*edge3B[0] - edge3A[0]*edge3B[2],
								 edge3A[0]*edge3B[1] - edge3A[1]*edge3B[0]};
			//normalize the cross product to calculate the normal for this vertex
			GLfloat length3 = sqrt(pow(cross3[0], 2) + pow(cross3[1], 2) + pow(cross3[2], 2));
			GLfloat normal3[3] = {cross3[0]/length3,
								  cross3[1]/length3,
								  cross3[2]/length3};
			
			///////////////////////////4///////////////////////
			//calculate surface edges adjacent to the vertex
			GLfloat edge4A[3] = {Piij[0] - Pij[0],
								 Piij[1] - Pij[1],
								 Piij[2] - Pij[2]};
			GLfloat edge4B[3] = {Piijj[0] - Pij[0],
								 Piijj[1] - Pij[1],
								 Piijj[2] - Pij[2]};

			//calculate cross product of the edges
			GLfloat cross4[3] = {edge4A[1]*edge4B[2] - edge4A[2]*edge4B[1],
								 edge4A[2]*edge4B[0] - edge4A[0]*edge4B[2],
								 edge4A[0]*edge4B[1] - edge4A[1]*edge4B[0]};
			//normalize the cross product to calculate the normal for this vertex
			GLfloat length4 = sqrt(pow(cross4[0], 2) + pow(cross4[1], 2) + pow(cross4[2], 2));
			GLfloat normal4[3] = {cross4[0]/length4,
								  cross4[1]/length4,
								  cross4[2]/length4};

			/////////////////////5////////////////////
			//calculate surface edges adjacent to the vertex
			GLfloat edge5A[3] = {Piijj[0] - Piij[0],
								 Piijj[1] - Piij[1],
								 Piijj[2] - Piij[2]};
			GLfloat edge5B[3] = {Pij[0] - Piij[0],
								 Pij[1] - Piij[1],
								 Pij[2] - Piij[2]};
			
			//calculate cross product of the edges
			GLfloat cross5[3] = {edge5A[1]*edge5B[2] - edge5A[2]*edge5B[1],
								 edge5A[2]*edge5B[0] - edge5A[0]*edge5B[2],
								 edge5A[0]*edge5B[1] - edge5A[1]*edge5B[0]};
			//normalize the cross product to calculate the normal for this vertex
			GLfloat length5 = sqrt(pow(cross5[0], 2) + pow(cross5[1], 2) + pow(cross5[2], 2));
			GLfloat normal5[3] = {cross5[0]/length5,
								  cross5[1]/length5,
								  cross5[2]/length5};
			
			/////////////////////6//////////////////////////
			//calculate surface edges adjacent to the vertex
			GLfloat edge6A[3] = {Pij[0] - Piijj[0],
								 Pij[1] - Piijj[1],
								 Pij[2] - Piijj[2]};
			GLfloat edge6B[3] = {Piij[0] - Piijj[0],
								 Piij[1] - Piijj[1],
								 Piij[2] - Piijj[2]};

			//calculate cross product of the edges
			GLfloat cross6[3] = {edge6A[1]*edge6B[2] - edge6A[2]*edge6B[1],
								 edge6A[2]*edge6B[0] - edge6A[0]*edge6B[2],
								 edge6A[0]*edge6B[1] - edge6A[1]*edge6B[0]};
			//normalize the cross product to calculate the normal for this vertex
			GLfloat length6 = sqrt(pow(cross6[0], 2) + pow(cross6[1], 2) + pow(cross6[2], 2));
			GLfloat normal6[3] = {cross6[0]/length6,
								  cross6[1]/length6,
								  cross6[2]/length6};

			//load calculated normals
			normals[nIndex+0] = normal1[0]; //x
			normals[nIndex+1] = normal1[1]; //y
			normals[nIndex+2] = normal1[2]; //z
			
			normals[nIndex+3] = normal2[0]; //x
			normals[nIndex+4] = normal2[1]; //y
			normals[nIndex+5] = normal2[2]; //z

			normals[nIndex+6] = normal3[0]; //x
			normals[nIndex+7] = normal3[1]; //y
			normals[nIndex+8] = normal3[2]; //z
			
			normals[nIndex+9] = normal4[0]; //x
			normals[nIndex+10] = normal4[1]; //y
			normals[nIndex+11] = normal4[2]; //z

			normals[nIndex+12] = normal5[0]; //x
			normals[nIndex+13] = normal5[1]; //y
			normals[nIndex+14] = normal5[2]; //z
			
			normals[nIndex+15] = normal6[0]; //x
			normals[nIndex+16] = normal6[1]; //y
			normals[nIndex+17] = normal6[2]; //z
			*/

			//texture coordinates
			vt[tIndex+0] = (j*(2*M_PI/stepsT))/(2*M_PI); //u value (theta)
			vt[tIndex+1] = (Pij[1]+1)/2; //v value

			vt[tIndex+2] = (j+1)*(2*M_PI/stepsT)/(2*M_PI); //u value (theta)
			vt[tIndex+3] = (Piijj[1]+1)/2; //v value

			vt[tIndex+4] = (j+1)*(2*M_PI/stepsT)/(2*M_PI); //u value (theta)
			vt[tIndex+5] = (Pijj[1]+1)/2; //v value

			vt[tIndex+6] = j*(2*M_PI/stepsT)/(2*M_PI); //u value (theta)
			vt[tIndex+7] = (Pij[1]+1)/2; //v value

			vt[tIndex+8] = j*(2*M_PI/stepsT)/(2*M_PI); //u value (theta)
			vt[tIndex+9] = (Piij[1]+1)/2; //v value

			vt[tIndex+10] = (j+1)*(2*M_PI/stepsT)/(2*M_PI); //u value (theta)
			vt[tIndex+11] = (Piijj[1]+1)/2; //v value
		}
	}
	
	
	// VAO -- vertex attribute objects bundle the various things associated with vertices
	GLuint vao;
	glGenVertexArrays (1, &vao);   // generating and binding is common pattern in OpenGL
	glBindVertexArray (vao);       // basically setting up memory and associating it

	// VBO -- vertex buffer object to contain coordinates
	// MODIFY THE FOLLOWING BLOCK OF CODE APPRORIATELY FOR YOUR SURFACE OF REVOLUTION
	GLuint points_vbo;
	glGenBuffers(1, &points_vbo);
	glBindBuffer(GL_ARRAY_BUFFER, points_vbo);
	glBufferData(GL_ARRAY_BUFFER, pointCount*18 * sizeof (GLfloat), vp, GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);
	glEnableVertexAttribArray(0);

	// VBO -- normals -- needed for shading calcuations
	// ADD CODE TO POPULATE AND LOAD PER-VERTEX SURFACE NORMALS  
	// [HINT] Vertex normals are organized in same order as that for vertex coordinates
	GLuint normals_vbo;
	glGenBuffers(1, &normals_vbo);
	glBindBuffer(GL_ARRAY_BUFFER, normals_vbo);
	glBufferData(GL_ARRAY_BUFFER, pointCount*18 * sizeof (GLfloat), normals, GL_STATIC_DRAW);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, NULL);
	glEnableVertexAttribArray(1);

    // VBO -- vt -- texture coordinates
	// ADD CODE TO POPULATE AND LOAD PER-VERTEX TEXTURE COORDINATES  
	// [HINT] texture coordinates are organized in same order as that for vertex coordinates
	// [HINT] there are two texture coordinates instead of three vertex coordinates for each vertex
	GLuint vt_vbo;
	glGenBuffers(1, &vt_vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vt_vbo);
	glBufferData(GL_ARRAY_BUFFER, pointCount*12 * sizeof (GLfloat), vt, GL_STATIC_DRAW);
	glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, NULL);
	glEnableVertexAttribArray(2);
}


	
void loadUniforms(GLuint shader_programme)
{	
/*---------------------------SET RENDERING DEFAULTS---------------------------*/

	// Choose vertex and fragment shaders to use as well as view and proj matrices.
	int model_mat_location = glGetUniformLocation (shader_programme, "model_mat");
	int view_mat_location  = glGetUniformLocation (shader_programme, "view_mat");
	int proj_mat_location  = glGetUniformLocation (shader_programme, "proj_mat");
	int light_pos_location  = glGetUniformLocation (shader_programme, "light_position");
	int light_col_location  = glGetUniformLocation (shader_programme, "light_color");
	
	glUniformMatrix4fv (view_mat_location, 1, GL_FALSE, view_mat.m);
	glUniformMatrix4fv (proj_mat_location, 1, GL_FALSE, proj_mat.m);
	glUniformMatrix4fv (model_mat_location, 1, GL_FALSE, model_mat.m);
	glUniform3f(light_pos_location, 0.0, 0.0, 10.0);
	glUniform3f(light_col_location, 1.0, 1.0, 1.0);
	
	// WRITE CODE TO LOAD OTHER UNIFORM VARIABLES LIKE FLAGS FOR ENABLING OR DISABLING CERTAIN FUNCTIONALITIES
}

void drawSurfaceOfRevolution()
{
	// MODIFY THIS LINE OF CODE APPRORIATELY FOR YOUR SURFACE OF REVOLUTION
	glDrawArrays(GL_TRIANGLES, 0, pointCount*18);
}
	
void keyboardFunction(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	// MODIFY THIS FUNCTION FOR KEYBOARD INTERACTIVITY
	//GLFW Reference Links:
	// Callback Example: https://www.glfw.org/docs/3.3/input_guide.html#input_key
	// List of Keys: https://www.glfw.org/docs/3.3/group__keys.html
	
    if (key == GLFW_KEY_E && action == GLFW_PRESS)
    {
		printf("\nKey 'E' pressed.... \n");
        // Example case. Key 'E' pressed. Doing nothing
	}
        
	if (GLFW_PRESS == glfwGetKey (g_window, GLFW_KEY_ESCAPE)) {
		// Close window when esacape is pressed
			glfwSetWindowShouldClose (g_window, 1);
	}

}
